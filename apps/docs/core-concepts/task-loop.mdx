---
title: "Task Loop"
description: "How SpinAI agents make and execute decisions, including detailed action execution timing"
---

## What is the Task Loop?

The task loop is SpinAI's core decision-making process that uses a planner to:

- Determine which actions to run
- Prepare parameters for each action
- Execute actions in sequence
- Generate final responses

## How it Works

The task loop uses a planner that leverages your agent's LLM for three key decisions:

1. **Planning Next Actions**

   - Analyzes user input and current state, including already executed actions, and results
   - Decides which actions should run next
   - Returns a list of action IDs to execute

2. **Parameter Preparation**

   - Before each action runs
   - Determines exact parameters needed
   - Uses context from previous actions and state to pass in specific parameters into your action

3. **Response Generation**

   - When no more actions are needed
   - Creates final response to user
   - Uses accumulated context and state
   - Defaults to a string, but you can pass in a responseFormat to get structured JSON (see [Agents](/core-concepts/agents))

## Flow Diagram

```mermaid
graph TD
    A[Agent Called] --> B[Plan Next Actions]
    B --> C{Actions Needed?}
    C -->|Yes| D[Prepare Action Parameters]
    D --> E[Execute Action]
    E --> B
    C -->|No| F[Generate Final Response]
```

## Detailed Action Execution Timing

The task loop has been enhanced to provide more detailed timing around action execution. This includes:

- **Entire Action Duration**: Measures the total time from the start of action preparation to the completion of the action execution. This is useful for understanding the overhead of parameter preparation and any cleanup that might be necessary after the action runs.
- **Action Execution Duration**: Specifically measures the time taken to execute the action itself, excluding preparation and cleanup. This metric is crucial for optimizing the performance of individual actions.

These timings help in identifying performance bottlenecks and understanding the overhead introduced by parameter preparation and action execution.

## Example Flow

```typescript
// 1. Agent gets called
const result = await agent({
  input: "Add 5 and 3, then subtract 2",
  state: {},
});

// 2. Planner decides actions: ["sum", "minus"]

// 3. For first action (sum):
// - Prepare parameters: { a: 5, b: 3 }
// - Execute sum action
// - Result stored in state

// 4. For second action (minus):
// - Prepare parameters: { a: 8, b: 2 }
// - Execute minus action
// - Result stored in state

// 5. No more actions needed
// - Generate final response
// - Return result to user
```

## Example showing how to measure and interpret action execution timing

```typescript
// Assuming an action "sum" is defined
const actionStartTime = Date.now();

// Execute the "sum" action
const context = await action.run(context, { a: 5, b: 3 });

const actionDuration = Date.now() - actionStartTime;
console.log(`Action execution time: ${actionDuration}ms`);
```

This example demonstrates how to measure the execution time of an action, which is crucial for performance analysis and optimization.

## Next Steps

<CardGroup>
  <Card title="Agents" icon="robot" href="/core-concepts/agents">
    Learn about agent configuration
  </Card>
  <Card
    title="State & Parameters"
    icon="database"
    href="/core-concepts/state-and-parameters"
  >
    Understand state management
  </Card>
</CardGroup>

Related Documentation:
- [Actions](/core-concepts/actions)
- [Observability](/core-concepts/observability)